<?xml version="1.0"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.0" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_0.xsd">
<name>lab9_soc</name>
<peripherals>
<peripheral>
      <name>lab9_soc_sysid_qsys_0_control_slave_altera_avalon_sysid</name><baseAddress>0x00000000</baseAddress> 
      <addressBlock>
        <offset>0x0</offset>
        <size>8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>     
         <name>ID</name>  
         <displayName>System ID</displayName>
            <description>A unique 32-bit value that is based on the contents of the QSys system. The id is similar to a check-sum value; QSys systems with different components, different configuration options, or both, produce different id values.</description>
         <addressOffset>0x0</addressOffset>
         <size>32</size>
         <access>read-only</access>
         <resetValue>${sysid_id_value}</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>id</name>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-only</access>
        </field>
       </fields>
     </register> 
        <register>
         <name>TIMESTAMP</name>  
         <displayName>Time stamp</displayName>
         <description>A unique 32-bit value that is based on the system generation time. The value is equivalent to the number of seconds after Jan. 1, 1970.</description>
         <addressOffset>0x4</addressOffset>
         <size>32</size>
         <access>read-only</access>
         <resetValue>${sysid_timestamp_value}</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>timestamp</name>
            <bitOffset>0x0</bitOffset>
            <bitWidth>32</bitWidth>
            <access>read-only</access>
        </field>
       </fields>
     </register>            
    </registers>
   </peripheral>
  <peripheral>
      <name>lab9_soc_jtag_uart_0_avalon_jtag_slave_altera_avalon_jtag_uart</name><baseAddress>0x00000000</baseAddress> 
      <addressBlock>
        <offset>0x0</offset>
        <size>8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>     
         <name>DATA</name>  
         <displayName>Data</displayName>
         <description>Embedded software accesses the read and write FIFOs via the data register. A read from the data register returns the first character from the FIFO (if one is available) in the DATA field. Reading also returns information about the number of characters remaining in the FIFO in the RAVAIL field. A write to the data register stores the value of the DATA field in the write FIFO. If the write FIFO is full, the character is lost.</description>
         <addressOffset>0x0</addressOffset>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>data</name>
           <description>The value to transfer to/from the JTAG core. When writing, the DATA field holds a character to be written to the write FIFO. When reading, the DATA field holds a character read from the read FIFO.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>8</bitWidth>
            <access>read-write</access>
        </field>
           <field><name>rvalid</name>
           <description>Indicates whether the DATA field is valid. If RVALID=1, the DATA field is valid, otherwise DATA is undefined.</description>
            <bitOffset>0xf</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
        </field>
           <field><name>ravail</name>
           <description>The number of characters remaining in the read FIFO (after the current read).</description>
            <bitOffset>0x10</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-only</access>
        </field>
       </fields>
     </register> 
        <register>     
         <name>CONTROL</name>  
         <displayName>Control</displayName>
         <description>Embedded software controls the JTAG UART core's interrupt generation and reads status information via the control register. A read from the control register returns the status of the read and write FIFOs. Writes to the register can be used to enable/disable interrupts, or clear the AC bit.</description>
         <addressOffset>0x4</addressOffset>
         <size>32</size>
         <access>read-write</access>
         <resetValue>0x0</resetValue>
         <resetMask>0xffffffff</resetMask> 
         <fields>
           <field><name>re</name>
            <description>Interrupt-enable bit for read interrupts.</description>
            <bitOffset>0x0</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
        </field>
           <field><name>we</name>
            <description>Interrupt-enable bit for write interrupts</description>
            <bitOffset>0x1</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
        </field>
           <field><name>ri</name>
            <description>Indicates that the read interrupt is pending.</description>
            <bitOffset>0x8</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
        </field>
           <field><name>wi</name>
            <description>Indicates that the write interrupt is pending.</description>
            <bitOffset>0x9</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-only</access>
        </field>
           <field><name>ac</name>
            <description>Indicates that there has been JTAG activity since the bit was cleared. Writing 1 to AC clears it to 0.</description>
            <bitOffset>0xa</bitOffset>
            <bitWidth>1</bitWidth>
            <access>read-write</access>
        </field>
           <field><name>wspace</name>
            <description>The number of spaces available in the write FIFO</description>
            <bitOffset>0x10</bitOffset>
            <bitWidth>16</bitWidth>
            <access>read-only</access>
        </field>
       </fields>
     </register>            
    </registers>
   </peripheral>
  <peripheral>
      <name>lab9_soc_TIMER_s1_altera_avalon_timer</name><baseAddress>0x00000000</baseAddress> 
      <addressBlock>
        <offset>0x0</offset>
        <size>16</size>
        <usage>registers</usage>
      </addressBlock>
       <registers>
         <register>     
          <name>status</name>  
          <displayName>Status</displayName>
          <description>The status register has two defined bits. TO (timeout), RUN</description>
          <addressOffset>0x0</addressOffset>
          <size>16</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xffff</resetMask>
          <fields>
            <field><name>TO</name>
            <description>The TO (timeout) bit is set to 1 when the internal counter reaches zero. Once set by a timeout event, the TO bit stays set until explicitly cleared by a master peripheral. Write zero to the status register to clear the TO bit.</description>
             <bitOffset>0x0</bitOffset>
             <bitWidth>1</bitWidth>
             <access>read-only</access>
             <readAction>clear</readAction>
            </field>
            <field><name>RUN</name>
            <description>The RUN bit reads as 1 when the internal counter is running; otherwise this bit reads as 0. The RUN bit is not changed by
 a write operation to the status register.</description>
             <bitOffset>1</bitOffset>
             <bitWidth>1</bitWidth>
             <access>read-only</access>
            </field>
            <field>
             <name>Reserved</name>
             <description>Reserved</description>
             <bitOffset>2</bitOffset>
             <bitWidth>14</bitWidth>
             <access>read-write</access>
             <parameters>
                 <parameter>
                 <name>Reserved</name>
                 <value>true</value>
                 </parameter>
             </parameters>
            </field>
          </fields>
        </register> 
        <register>
            <name>control</name>
            <description>The control register has four defined bits. ITO (Timeout Interrupt), CONT (continue), START, STOP</description>
            <addressOffset>0x1</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <reset>
                <value>0x0</value>
            </reset>
            <field>
                <name>ITO</name>
                <description>If the ITO bit is 1, the interval timer core generates an IRQ when the status register's TO bit is 1. When the ITO bit is 0, the timer does not generate IRQs.</description>
                <bitOffset>0</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
            </field>
            <field>
                <name>CONT</name>
                <description>The CONT (continuous) bit determines how the internal counter behaves when it reaches zero. If the CONT bit is 1, the counter runs continuously until it is stopped by the STOP bit. If CONT is 0, the counter stops after it reaches zero. When the counter reaches zero, it reloads with the value stored in the period registers, regardless of the CONT bit.</description>
                <bitOffset>1</bitOffset>
                <bitWidth>1</bitWidth>
                <access>read-write</access>
            </field>
            <field>
                <name>START</name>
                <description>Writing a 1 to the START bit starts the internal counter running (counting down). The START bit is an event bit that enables the counter when a write operation is performed. If the timer is stopped, writing a 1 to the START bit causes the timer to restart counting from the number currently stored in its counter. If the timer is already running, writing a 1 to START has no effect. Writing 0 to the START bit has no effect.</description>
                <bitOffset>2</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
            </field>
            <field>
                <name>STOP</name>
                <description>Writing a 1 to the STOP bit stops the internal counter. The STOP bit is an event bit that causes the counter to stop when a write operation is performed. If the timer is already stopped, writing a 1 to STOP has no effect. Writing a 0 to the stop bit has no effect. If the timer hardware is configured with Start/Stop control bits off, writing the STOP bit has no effect.</description>
                <bitOffset>3</bitOffset>
                <bitWidth>1</bitWidth>
                <access>write-only</access>
            </field>
            <field>
                <name>Reserved</name>
                <description>Reserved</description>
                <bitOffset>4</bitOffset>
                <bitWidth>12</bitWidth>
                <access>read-write</access>
                <parameters>
                    <parameter>
                    <name>Reserved</name>
                    <value>true</value>
                    </parameter>
                </parameters>
            </field>
        </register>
        <register>
            <name>${period_name_0}</name>
            <description>The period_n registers together store the timeout period value when a write operation to one of the period_n register or the internal counter reaches 0. The timer's actual period is one cycle greater than the value stored in the period_n registers because the counter assumes the value zero for one clock cycle. Writing to one of the period_n registers stops the internal counter, except when the hardware is configured with Start/Stop control bits off. If Start/Stop control bits is off, writing either register does not stop the counter. When the hardware is configured with Writeable period disabled, writing to one of the period_n registers causes the counter to reset to the fixed Timeout Period specified at system generation time.</description>
            <addressOffset>0x2</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_name_0_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_name_1}</name>
            <description></description>
            <addressOffset>0x3</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_name_1_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_snap_0}</name>
            <description></description>
            <addressOffset>0x4</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_snap_0_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${period_snap_1}</name>
            <description></description>
            <addressOffset>0x5</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>${period_snap_1_reset_value}</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_0}</name>
            <description>A master peripheral may request a coherent snapshot of the current internal counter by performing a write operation (write-data ignored) to one of the snap_n registers. When a write occurs, the value of the counter is copied to snap_n registers. The snapshot occurs whether or not the counter is running. Requesting a snapshot does not change the internal counter's operation.</description>
            <addressOffset>0x6</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_1}</name>
            <description></description>
            <addressOffset>0x7</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_2}</name>
            <description></description>
            <addressOffset>0x8</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
        <register>
            <name>${snap_3}</name>
            <description></description>
            <addressOffset>0x9</addressOffset>
            <size>16</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xffff</resetMask>
        </register>
    </registers>
   </peripheral>
  </peripherals>
</device>